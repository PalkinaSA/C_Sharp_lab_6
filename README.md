# Лабораторная работа №6 по дисциплине "Язык программирования C#"
# Текст задания:
Лабораторная работа БЕЗ вариантов. Необходимо выполнить ВСЕ задания в одном проекте. В классах 
могут присутствовать методы со спецификатором доступа private вспомогательного характера. 
Организовать проверку входных данных. К каждому классу и методу написать xml-документацию. 
Каждая задача оценивается по 3 балла, xml-документация оценивается в 2 балла. Максимально за 
лабораторную работу можно получить 10 баллов (8 баллов за решение задач + 2 балла за оформление 
отчета). За решение с использованием шаблонов можно получить дополнительные 5 баллов, которые 
можно добавить к любой контрольной точке. 

Задание 1. Кот 

1.1. Кот мяукает. 
Создайте сущность Кот, которая описывается следующим образом: 
1. Имеет Имя (строка) 
2. Для создания необходимо указать имя кота. 
3. Может быть приведен к текстовой форме вида: “кот: Имя” 
4. Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
вызвать мяуканье можно без параметров. 
5. Может помяукать N раз, что приводит к выводу на экран следующего текста: “Имя: мяу
мяу-…-мяу!”, где количество “мяу”равно N.

Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза. 

1.2. Интерфейс Мяуканье. 
Разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у 
каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой: 
public void meow(); 
Дополните решение предыдущей задачи так, чтобы иметь возможность передать Кота в написанный 
вами метод и протестируйте работоспособность решения передав в него нескольких котов, а также 
создайте любой другой произвольный класс и передайте в написанный метод его объекты. 

1.3. Количество мяуканий.  
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из предыдущего 
задания. Необходимо таким образом передать кота в указанный метод, что бы после окончания его 
работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед 
вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы 
выводим количество мяуканий на экран. Кота изменять нельзя. 

Задание 2. Дроби 

2.1. Дроби.  
Создайте сущность Дробь со следующими особенностями: 
1. Имеет числитель: целое число 
2. Имеет знаменатель: целое число 
3. Дробь может быть создана с указанием числителя и знаменателя  
4. Может вернуть строковое представление вида “числитель/знаменатель” 
5. Может выполнять операции сложения, вычитания, умножения и деления с другой 
Дробью или целым числом. Результатом операции должна быть новая Дробь (таким 
образом, обе исходные дроби не изменяются) (Обязательно использовать перегрузки!) 
6. Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не 
может быть отрицательным.
 
Затем необходимо выполнить следующие задачи: 
1. Создать несколько экземпляров дробей. 
2. Написать по одному примеру использования каждого метода. 
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9» 
4. Посчитать f1.sum(f2).div(f3).minus(5)

2.2. Сравнение дробей.  
Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя. 

2.3. Клонирование дроби. Интерфейс ICloneable. 
Переопределите метод клонирования, таким образом, чтобы при его вызове возвращался новый 
объект Дроби, значения полей которого будут копиями оригинальной Дроби. 

2.4. В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 

# Алгоритм решения:
0. В классе Program создаём 2 приватных статических метода Ex1() и Ex2() для выполнения заданий. В Main() вызываем их последовательно. Все методы, свойства, классы и интерфейсы сопровождаем xml-документацией.

Задание 1. Кот
1. Создаём класс Cat (Кот). Задаём ему приватное поле _name и публичное свойство Name (Имя). В свойстве проверяем на передачу пустой или нулевой строки. Создаём конструктор кота с параметром name. В классе кот переопределяем метод ToString() для вывода кота в виде "кот: Имя". Также вводим методы meow() без параметров и с параметром times, чтобы была возможность задать коту количество мяуканий. Каждый метод, свойство и сам класс сопровождаем xml-документацией. В методе Ex1() создаём Барсика и заставляем его мяукнуть 1 раз, затем 3 раза.
2. Создаём интерфейс Meowable (интерфейс, придающий способностью мяукать). В нём определяем методы meow без параметров и с параметром times. Наделяем этим интерфейсом наш исхожный класс Cat.
3. Создаём статический класс Funs для метода meowCare(), принимающего множество мяукающих объектов. Метод meowCare() может получить один или несколько мяукающих объектов, чтобы затем дать им поочереди помяукать. 
4. Создаём класс ElectroCat с интерфейсом Meowable, чтобы он мог мяукать. У электро-кота есть имя и название двигателя. При создании электро-кота нужно указать эти два параметра. При мяуканьи он произносит название своего двигателя. Переопределяем метод ToString().
5. В методе Ex1() создаём несколько мяукающих объектов типа котов. Передаём их в метод meowCare(). Затем создаём объекты электро-котов и тоже передаём их в метод meowCare().
6. Затем создаём специальный класс MeowCounter с интерфейсом Meowable, чтобы можно было считать количество мяуканий мяукающих объектов. Он принимает в себя мяуающий объект и количество мяуканий. Создаём конструктор с параметром в виде мяукающего объекта. Определяем методы meow без параметров и с параметром times так, чтобы они считали количество мяуканий. Перегружаем метод ToString().
7. В методе Ex1() задаём объект счётчика мяуканий для одного из котов. Вызываем функцию meowCare() для счётчика мяуканий. Выводим на экран количество мяуканий.

Задание 2. Дроби
1. Создаём класс Fraction (Дробь) с приватными полями _numerator и _denominator и публичными свойствами Numerator (Числитель) и Denominator (Знаменатель). Создаём конструктор с параметрами числителя и знаменателя. В данном классе переопределяем метод ToString(), чтобы он выводил строку дроби в виде "числитель/знаменатель". Перегружаем операции сложения, вычитания, умножения и деления дробей. Такде перегружаем данные операции при работе с дробью и целым числом. Добавляем приватный метод Reduce (метод сокращения дроби) и статический приватный метод GCD (метод поиска наибольшего общего делителя) для сокращения дроби до минимально возможных её значений числителя и знаменателя, чтобы при этом её вещественное значение осталось исходным. Каждый метод, свойство и сам класс сопровождаем xml-документацией. Обрабатываем в свойствах отрицательные значения знаменателя (меняем знак числителя, а знаменатель делаем положительным). Обрабатываем значение 0 в знаменателе (выводим на экран сообщение о делении на ноль и выставляем значения числителя и знаменателя на 0 и 1). Заводим методы sum, minus, mult и div, работающие с дробями и целыми числами. Эти методы вовращают новую дробь в виде результата. В методе Ex2() создаём несколько экземпляров дробей и проводим все возможные операций над этими дробями. Результаты выводим на экран. Вычисляем значение выражения f1.sum(f2).div(f3).minus(5) и выводим на экран.
2. В классе дроби переопределяем метод Equals для сравнения дробей и метод GetHashCode (нужно обязательно переопределять при переопределении метода Equals). Equals считает дроби одинаковыми, если числители и знаменатели равны и тип передаваемого объекта равен Fraction. В методе Ex2() пробуем сравнить дробь с другой дробью, дробь с новой дробью с одинаковыми значениями и дробь с вещественным числом. Результаты выводим на экран.
3. Добавляем к классу Fraction интерфейс ICloneable и переопредяем метод Clone для клонирования дроби (получения нового объекта дроби с идентичными значениями числителя и знаменателя). В методе Ex2() пробуем клонировать дробь (обязательно приводим к типу Fraction явно, так как метод Clone возвращает объект типа object) и выводим результаты на экран.
4. Создаём интерфейс IFractionable с методом GetDecimalValue (вычисление вещественного значения дроби), а также методами SetNumerator (установка числителя) и SetDenominator (установка знаменателя), принимающими целое число в качестве параметра для установки. Данный интерфейс применяем на класс Fraction. Определяем методы GetDecimalValue (возвращает double), SetNumerator, SetDenominator (ничего не возвращают) в классе Fraction.
5. Создаём новый класс для кэширования дроби CachedFraction с интерфейсом IFractionable. В нём есть приватное вещественное поле _cachedDoubleValue (изначально равно null) для хранения вещественного значения передаваемой дроби и приватное поле _fraction типа Fraction для хранения самой дроби. Определяем конструктор с параметром типа Fraction для создания кэшированной дроби. В конструкторе вычисляется вещественное значение передаваемой дроби и записывается в поле _cachedDoubleValue. Опредяем методы GetDoubleValue(), SetNumerator и SetDenominator в данном классе. При получении новых значений для дроби (установки нового числителя или установки знаменателя) _cachedDoubleValue сбрасывается в null. При вызове метода GetDoubleValue() кэш заново пересчитывается. Переопределяем метод ToString(). В методе Ex2() создаём новую дробь и выводим её вещественное значение на экран. Пробуем изменить её значение через SetNumerator и SetDenominator, выводим новое вещественное значение дроби. Создаём кэшированную дробь на основе ранее созданой дроби. Выводим её вещественное значение на экран, изменяем значения числителя и знаменателя. Выводим результаты на экран.
# Тестирование:
